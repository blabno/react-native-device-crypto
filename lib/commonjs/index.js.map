{"version":3,"sources":["index.ts"],"names":["RNDeviceCrypto","NativeModules","DeviceCrypto","AccessLevel","KeyTypes","BiometryType","SecurityLevel","getOrCreateAsymmetricKey","alias","options","createKey","keyType","ASYMMETRIC","getOrCreateSymmetricKey","SYMMETRIC","deleteKey","Boolean","getPublicKey","sign","plainText","encrypt","decrypt","iv","isKeyExists","isBiometryEnrolled","deviceSecurityLevel","getBiometryType","authenticateWithBiometry","err"],"mappings":";;;;;;;AAAA;;AAEA,MAAMA,cAAc,GAAGC,2BAAcC,YAArC;IAQYC,W;;;WAAAA,W;AAAAA,EAAAA,W,CAAAA,W;AAAAA,EAAAA,W,CAAAA,W;AAAAA,EAAAA,W,CAAAA,W;GAAAA,W,2BAAAA,W;;IAUAC,Q;;;WAAAA,Q;AAAAA,EAAAA,Q,CAAAA,Q;AAAAA,EAAAA,Q,CAAAA,Q;AAAAA,EAAAA,Q,CAAAA,Q;GAAAA,Q,wBAAAA,Q;;IAUAC,Y;;;WAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;GAAAA,Y,4BAAAA,Y;;IAOAC,a;;;WAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;GAAAA,a,6BAAAA,a;;AAMZ,MAAMJ,YAAY,GAAG;AACnB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE,QAAMK,wBAAN,CACEC,KADF,EAEEC,OAFF,EAGmB;AACjB,WAAOT,cAAc,CAACU,SAAf,CAAyBF,KAAzB,EAAgC,EACrC,GAAGC,OADkC;AAErCE,MAAAA,OAAO,EAAEP,QAAQ,CAACQ;AAFmB,KAAhC,CAAP;AAID,GAnBkB;;AAqBnB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACE,QAAMC,uBAAN,CACEL,KADF,EAEEC,OAFF,EAGoB;AAClB,WAAOT,cAAc,CAACU,SAAf,CAAyBF,KAAzB,EAAgC,EACrC,GAAGC,OADkC;AAErCE,MAAAA,OAAO,EAAEP,QAAQ,CAACU;AAFmB,KAAhC,CAAP;AAID,GArCkB;;AAuCnB;AACF;AACA;AACA;AACA;AACE,QAAMC,SAAN,CAAgBP,KAAhB,EAAiD;AAC/C,WAAOQ,OAAO,CAAChB,cAAc,CAACe,SAAf,CAAyBP,KAAzB,CAAD,CAAd;AACD,GA9CkB;;AAgDnB;AACF;AACA;AACA;AACA;AACE,QAAMS,YAAN,CAAmBT,KAAnB,EAAmD;AACjD,WAAOR,cAAc,CAACiB,YAAf,CAA4BT,KAA5B,CAAP;AACD,GAvDkB;;AAyDnB;AACF;AACA;AACA;AACA;AACA;AACE,QAAMU,IAAN,CACEV,KADF,EAEEW,SAFF,EAGEV,OAHF,EAImB;AACjB,WAAOT,cAAc,CAACkB,IAAf,CAAoBV,KAApB,EAA2BW,SAA3B,EAAsCV,OAAtC,CAAP;AACD,GArEkB;;AAuEnB;AACF;AACA;AACA;AACA;AACA;AACE,QAAMW,OAAN,CACEZ,KADF,EAEEW,SAFF,EAGEV,OAHF,EAI6B;AAC3B,WAAOT,cAAc,CAACoB,OAAf,CAAuBZ,KAAvB,EAA8BW,SAA9B,EAAyCV,OAAzC,CAAP;AACD,GAnFkB;;AAqFnB;AACF;AACA;AACA;AACA;AACA;AACA;AACE,QAAMY,OAAN,CACEb,KADF,EAEEW,SAFF,EAGEG,EAHF,EAIEb,OAJF,EAKmB;AACjB,WAAOT,cAAc,CAACqB,OAAf,CAAuBb,KAAvB,EAA8BW,SAA9B,EAAyCG,EAAzC,EAA6Cb,OAA7C,CAAP;AACD,GAnGkB;;AAqGnB;AACF;AACA;AACA;AACA;AACE,QAAMc,WAAN,CAAkBf,KAAlB,EAAiCG,OAAjC,EAAsE;AACpE,WAAOX,cAAc,CAACuB,WAAf,CAA2Bf,KAA3B,EAAkCG,OAAlC,CAAP;AACD,GA5GkB;;AA8GnB;AACF;AACA;AACA;AACA;AACE,QAAMa,kBAAN,GAA6C;AAC3C,WAAOxB,cAAc,CAACwB,kBAAf,EAAP;AACD,GArHkB;;AAuHnB;AACF;AACA;AACA;AACA;AACE,QAAMC,mBAAN,GAAoD;AAClD,WAAOzB,cAAc,CAACyB,mBAAf,EAAP;AACD,GA9HkB;;AAgInB;AACF;AACA;AACA;AACA;AACE,QAAMC,eAAN,GAA+C;AAC7C,WAAO1B,cAAc,CAAC0B,eAAf,EAAP;AACD,GAvIkB;;AAyInB;AACF;AACA;AACA;AACA;AACE,QAAMC,wBAAN,CAA+BlB,OAA/B,EAA0E;AACxE,QAAI;AACF,aAAOT,cAAc,CAAC2B,wBAAf,CAAwClB,OAAxC,CAAP;AACD,KAFD,CAEE,OAAOmB,GAAP,EAAiB;AACjB,YAAMA,GAAN;AACD;AACF;;AApJkB,CAArB;eAuJe1B,Y","sourcesContent":["import { NativeModules } from 'react-native';\n\nconst RNDeviceCrypto = NativeModules.DeviceCrypto;\n\nexport interface BiometryParams {\n  biometryTitle: string;\n  biometrySubTitle: string;\n  biometryDescription: string;\n}\n\nexport enum AccessLevel {\n  ALWAYS = 0,\n  UNLOCKED_DEVICE = 1,\n  AUTHENTICATION_REQUIRED = 2,\n}\nexport interface KeyCreationParams {\n  accessLevel: AccessLevel;\n  invalidateOnNewBiometry?: boolean;\n}\n\nexport enum KeyTypes {\n  ASYMMETRIC = 0,\n  SYMMETRIC = 1,\n  ASYMMETRIC_ENCRYPTION = 2,\n}\nexport interface EncryptionResult {\n  iv: string;\n  encryptedText: string;\n}\n\nexport enum BiometryType {\n  NONE = 'NONE',\n  TOUCH = 'TOUCH',\n  FACE = 'FACE',\n  IRIS = 'IRIS',\n}\n\nexport enum SecurityLevel {\n  NOT_PROTECTED = 'NOT_PROTECTED',\n  PIN_OR_PATTERN = 'PIN_OR_PATTERN',\n  BIOMETRY = 'BIOMETRY',\n}\n\nconst DeviceCrypto = {\n  /**\n   * Create public/private key pair inside the secure hardware or get the existing public key\n   * Secure enclave/TEE/StrongBox\n   *\n   * Cryptography algorithms\n   * EC secp256k1 on iOS\n   * EC secp256r1 on Android\n   *\n   * @return {Promise} Resolves to public key when successful\n   */\n  async getOrCreateAsymmetricKey(\n    alias: string,\n    options: KeyCreationParams\n  ): Promise<string> {\n    return RNDeviceCrypto.createKey(alias, {\n      ...options,\n      keyType: KeyTypes.ASYMMETRIC,\n    });\n  },\n\n  /**\n   * Create AES key inside the secure hardware. Returns `true` if the key already exists.\n   * Secure enclave/TEE/StrongBox\n   *\n   * Cryptography algorithms AES256\n   *\n   * @return {Promise} Resolves to `true` when successful\n   */\n  async getOrCreateSymmetricKey(\n    alias: string,\n    options: KeyCreationParams\n  ): Promise<boolean> {\n    return RNDeviceCrypto.createKey(alias, {\n      ...options,\n      keyType: KeyTypes.SYMMETRIC,\n    });\n  },\n\n  /**\n   * Delete the key from secure hardware\n   *\n   * @return {Promise} Resolves to `true` when successful\n   */\n  async deleteKey(alias: string): Promise<boolean> {\n    return Boolean(RNDeviceCrypto.deleteKey(alias));\n  },\n\n  /**\n   * Get the public key as PEM formatted\n   *\n   * @return {Promise} Resolves to public key when successful\n   */\n  async getPublicKey(alias: string): Promise<string> {\n    return RNDeviceCrypto.getPublicKey(alias);\n  },\n\n  /**\n   * Signs the given text with given private key\n   *\n   * @param {String} plainText Text to be signed\n   * @return {Promise} Resolves to signature in `Base64` when successful\n   */\n  async sign(\n    alias: string,\n    plainText: string,\n    options: BiometryParams\n  ): Promise<string> {\n    return RNDeviceCrypto.sign(alias, plainText, options);\n  },\n\n  /**\n   * Encrypt the given text\n   *\n   * @param {String} plainText Text to be encrypted\n   * @return {Promise} Resolves to encrypted text `Base64` formatted\n   */\n  async encrypt(\n    alias: string,\n    plainText: string,\n    options: BiometryParams\n  ): Promise<EncryptionResult> {\n    return RNDeviceCrypto.encrypt(alias, plainText, options);\n  },\n\n  /**\n   * Decrypt the encrypted text with given IV\n   *\n   * @param {String} plainText Text to be signed\n   * @param {String} iv Base64 formatted IV\n   * @return {Promise} Resolves to decrypted text when successful\n   */\n  async decrypt(\n    alias: string,\n    plainText: string,\n    iv: string,\n    options: BiometryParams\n  ): Promise<string> {\n    return RNDeviceCrypto.decrypt(alias, plainText, iv, options);\n  },\n\n  /**\n   * Checks the key existence\n   *\n   * @return {Promise} Resolves to `true` if exists\n   */\n  async isKeyExists(alias: string, keyType: KeyTypes): Promise<boolean> {\n    return RNDeviceCrypto.isKeyExists(alias, keyType);\n  },\n\n  /**\n   * Checks the biometry is enrolled on device\n   *\n   * @returns {Promise} Resolves `true` if biometry is enrolled on the device\n   */\n  async isBiometryEnrolled(): Promise<boolean> {\n    return RNDeviceCrypto.isBiometryEnrolled();\n  },\n\n  /**\n   * Checks the device security level\n   *\n   * @return {Promise} Resolves one of `SecurityLevel`\n   */\n  async deviceSecurityLevel(): Promise<SecurityLevel> {\n    return RNDeviceCrypto.deviceSecurityLevel() as SecurityLevel;\n  },\n\n  /**\n   * Returns biometry type already enrolled on the device\n   *\n   * @returns {Promise} Resolves `BiometryType`\n   */\n  async getBiometryType(): Promise<BiometryType> {\n    return RNDeviceCrypto.getBiometryType() as BiometryType;\n  },\n\n  /**\n   * Authenticate user with device biometry\n   *\n   * @returns {Promise} Resolves `true` if user passes biometry or fallback pin\n   */\n  async authenticateWithBiometry(options: BiometryParams): Promise<boolean> {\n    try {\n      return RNDeviceCrypto.authenticateWithBiometry(options);\n    } catch (err: any) {\n      throw err;\n    }\n  },\n};\n\nexport default DeviceCrypto;\n"]}